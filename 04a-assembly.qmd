---
title: "04a Assembly"
format:
  html:
    smooth-scroll: true
    highlight-style: github 
    embed-resources: true
    code-overflow: scroll
    code-block-background: true
---

# Assembly {#sec-assembly}

::: {.callout-note icon="false"}
## Time

-   Teaching: 30 min
-   Exercises: 10 min
:::

::: {.callout-tip icon="false"}
## Questions

-   Why should genomic data be assembled?
-	What is the difference between reads and contigs?
-	How can we assembly a metagenome?
:::

::: {.callout-warning icon="false"}
## Objectives

-	Understand what an assembly is
-	Run a metagenomics assembly workflow

:::

## Assembling reads
The assembly process groups reads into contigs and contigs into 
scaffolds to obtain (ideally) the sequence of a whole 
chromosome. There are many programs devoted to
[genome](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2874646/) and 
metagenome assembly, some of the main strategies they use are Greedy extension, OLC, and De Bruijn charts. 
Contrary to metabarcoding, shotgun metagenomics needs an assembly step, which does not mean that metabarcoding never uses an assembly step but sometimes is unnecessary.

![Overview of Different Methods of Genome Assembly](fig/04a-01.png)

[MetaSPAdes](https://github.com/ablab/spades) is an NGS de novo assembler 
for assembling large and complex metagenomics data, and it is one of the 
most used and recommended. It is part of the SPAdes toolkit, which 
contains several assembly pipelines.

Some of the problems faced by metagenomics assembly are:  
* Differences in coverage between the genomes due to the differences in abundance in the sample.  
* The fact that different species often share conserved regions.  
* The presence of several strains of a single species in the community.   

SPAdes already deals with the non-uniform coverage problem in its algorithm, so it is helpful for the assembly of simple communities, 
but the [metaSPAdes](https://pubmed.ncbi.nlm.nih.gov/28298430/) algorithm deals with the other problems as well, allowing it to assemble metagenomes from complex communities. 

The process of (metagenomics) assembly can take a long time, therefore we will use subset of our data for this step.

## MetaSPAdes is a metagenomics assembler

Running metaSPAdes in Galaxy requires us to provide some information.  First we will select the format of our paired-end reads, this will be **Paired-end: individual datasets**, then we select our forward and reverse trimmed reads.  After this we need to specify the type of paired-reads we have, ours is the default **--pe**.

Next, we need to make sure the the orientation of our reads is correct, by default it is **FR(-> <-)** and that is the orientation of our reads.  Finally, we can check that **the samples belong to the same library** is set to True.  Everything else we can leave as default.  Then we can run the tool.

Once MetaSPAdes completes, you will have 4 outputs:

+ metaSPAdes on X data and Y data: Scaffolds
+ metaSPAdes on X data and Y data: Contigs
+ metaSPAdes on X data and Y data: Assembly graph with scaffolds
+ metaSPAdes on X data and Y data: Assembly graph

As we can see, MetaSPAdes gave us a few files to look at. The ones with the assembly are the `metaSPAdes on X data and Y data: Contigs` and the `metaSPAdes on X data and Y data: Scaffolds`. 

The files `metaSPAdes on X data and Y data: Assembly graph` and `metaSPAdes on X data and Y data: Assembly graph with scaffolds` have the information needed to visualize  our assembly by different means, like programs such as [Bandage](https://rrwick.github.io/Bandage/).

The contigs are just made from assembled reads, but the scaffolds are the result 
from a subsequent process in which the contigs are ordered, oriented, and connected with Ns.

As before, the output from metaSPAdes as given us long, difficult to decipher names, therefore it would be good to rename the files.  This will make it easier to keep track of our data.


::: {.callout-tip icon="false"}

## Exercise 1: Compare the two fasta files from the assembly output

You want to know how many contigs and scaffolds result from the assembly. 
Use `contigs.fasta`  and `scaffolds.fasta ` files and the tool **Select last lines from a dataset**, found under the **Text Manipulation** group, to compare the number of contigs generated for each file.   

Do they have the same number of contigs? Why?  

:::

::: {.callout-tip collapse="true" icon="false"}

## Solution

A contig is created from reads and then a scaffold from a group of contigs, so we expect fewer total contigs in the `scaffolds.fasta`.

:::

::: {.callout-warning icon="false"}
## Quality of assemblies

You can use several metrics to know the quality of your assemblies. [MetaQuast](https://quast.sourceforge.net/metaquast.html) is a program
that gives you these metrics for metagenome assemblies in an interactive report and text files and plots.

:::

::: {.callout-caution icon="false"}
## Keypoints

-	Assembly groups reads into contigs
-	De Bruijn Graphs use Kmers to assemble cleaned reads
-	MetaSPAdes is a metagenomes assembler
-	Assemblers take FastQ files as input and produce Fasta files as output

:::
